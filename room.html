<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pictionary Game</title>
    <link rel="stylesheet" href="main.css">
</head>
<body>
    <div class="room">
        <div class="appbar"></div>
        <div class="toolbox"></div>
        <div class="whiteboard">
            <canvas id="canvas"></canvas>
        </div>
        <div class="cameraview">
            <div id="vid_remote"></div>
        </div>
        <div class="chat"></div>
    </div>
<script type="text/javascript" src="CanvasController.js"></script>
<script type="text/javascript">
    new CanvasController(document.getElementById("canvas"));
</script>
<script type="text/javascript">

    let ws = undefined;

    let streamLocal = undefined;
    let streamLocalReady = false;

    let room = parseInt(window.location.pathname.split('/',3)[2]);
    let pass = undefined;
    if (room === undefined || isNaN(room) || room < 0) {
        window.location = '/';
    }
    else {
        document.title = 'Pictionary Game (room ' + room + ')';
        createWebSocket();
        // createWebSocket().then(sock => {
        //     ws = sock;
        //     joinRoom(room, pass);
        // }).catch(() => {
        //     alert('Could not create WebSocket connection to server');
        // });
    }

    function createWebSocket() {
        let host = window.location.hostname;
        let port = 9004;
        let sock = new WebSocket('wss://' + host + ':' + port);
        sock.onopen = event => {
            ws = sock;
            joinRoom(room, pass);
        };
        sock.onerror = event => {
            alert('Could not create WebSocket connection to server');
        };
        sock.onmessage = event => {
            onWebSocketMessage(event.data);
        }
    }

    function onWebSocketMessage(m) {
        if (typeof m === 'string') {
            try {
                m = JSON.parse(m);
                // console.log('json');
                // console.log(m);
                if (m.join !== undefined) {
                    onMessageJoin(m.join);
                }
                if (m.peers !== undefined) {
                    onMessagePeers(m.peers);
                }
                if (m.init !== undefined) {
                    onMessageInit(m.init);
                }
                if (m.signal !== undefined && typeof m.signal.peer === 'number' && m.signal.signal !== undefined) {
                    onMessageSignal(m.signal.peer, m.signal.signal);
                }
                //TODO: other json data
            }
            catch(err) {
                console.log('string');
                console.log(m);
                //TODO: non json data
            }
        }
        else {
            console.log('binary');
            //TODO: binary data
        }
    }

    function joinRoom(room, pass) {
        if (typeof pass === 'string') {
            ws.send(JSON.stringify({join:{room:room,pass:pass}}));
        }
        else {
            ws.send(JSON.stringify({join:{room:room}}));
        }
    }

    function onMessageJoin(m) {
        if (m.needPass === true) {
            pass = prompt('Enter room password:', '');
            if (pass === null || pass === undefined || pass === '') {
                window.location = '/';
                alert('Could not enter room ' + room);
            }
            else {
                joinRoom(room, pass);
            }
            return;
        }
        else if (m.success === false) {
            window.location = '/';
            alert('Could not enter room ' + room);
            return;
        }
        requestUserMedia();
    }

    function requestUserMedia() {
        navigator.getUserMedia = navigator.getUserMedia ||
            navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia;
        if (navigator.getUserMedia === undefined) {
            console.log('getUserMedia not supported by browser');
            alert('getUserMedia not supported by browser');
            onLocalStream(undefined, false, false);
            return;
        }
        navigator.getUserMedia({audio: true, video: true}, s => {
            onLocalStream(s, true, true);
        }, event => {
            console.log('Could not retrieve video input device');
            alert('Could not retrieve video input device');
            navigator.getUserMedia({audio: true}, s => {
                onLocalStream(s, false, true);
            }, event => {
                console.log('Could not retrieve audio input device');
                alert('Could not retrieve audio input device');
                onLocalStream(undefined, false, false);
            });
        });
    }

    function onLocalStream(s, video, audio) {
        if (s === undefined || (!audio && !video)) return undefined;
        streamLocal = s;
        streamLocalReady = true;
        if (video || audio) {
            elem = document.getElementById('vid_local');
            if (elem !== undefined && elem !== null) {
                document.getElementById('vid_local').src = window.URL.createObjectURL(streamLocal);
                if (video)
                    document.getElementById('vid_local').style.display = 'inline';
            }
        }
        ws.send(JSON.stringify({peers:0}));
    }

    let peersProcessed = 0;
    let peers = [];
    function onMessagePeers(p) {
        if (!streamLocalReady || typeof p !== 'number' || p <= 0) return;
        for (let i = peersProcessed; i < p; i++, peersProcessed++) {
            peers.push(new RTCPeerConnection({
                iceServers: [
                    {url: 'stun:stun.l.google.com:19302'}
                ]
            }));
        }
    }

    function onMessageInit(p) {
        if (typeof p !== 'number' || p < 0) return;
        if (p >= peersProcessed) {
            setTimeout(() => {onMessageInit(p);},100);
            return;
        }
        if (streamLocal !== undefined) {
            peers[p].addStream(streamLocal);
        }
        peers[p].createOffer({offerToReceiveAudio: true, offerToReceiveVideo:true}).then(offer => {
            peers[p].setLocalDescription(offer);
            ws.send(JSON.stringify({signal:{peer:p,signal:{offer:offer}}}));
        });
        peers[p].onicecandidate = event => {
            if (event.candidate) {
                ws.send(JSON.stringify({signal:{peer:p,signal:{ice:event.candidate}}}));
            }
        };
        peers[p].onaddstream = event => {
            node = createVideoNode(p);
            node.src = window.URL.createObjectURL(event.stream);
        };
        peers[p].oniceconnectionstatechange = event => {
            if (peers[p].iceConnectionState === 'failed' || peers[p].iceConnectionState === 'disconnected') {
                let node = document.getElementById('vid_remote_' + p);
                if (node !== undefined) {
                    node.parentElement.removeChild(node);
                }
                peers[p] = undefined;
            }
        };
    }

    function onMessageSignal(p,s) {
        if (typeof p !== 'number' || p < 0 || s === undefined) return;
        if (p >= peersProcessed) {
            setTimeout(() => {onMessageSignal(p,s);},100);
            return;
        }
        if (typeof s.ice !== 'undefined') {
            peers[p].addIceCandidate(s.ice).catch(event => {
                // console.log(event);
            });
        }
        if (s.offer !== undefined) {
            peers[p].setRemoteDescription(s.offer);
            if (streamLocal !== undefined) {
                peers[p].addStream(streamLocal);
            }
            peers[p].onicecandidate = event => {
                if (event.candidate) {
                    ws.send(JSON.stringify({signal:{peer:p,signal:{ice:event.candidate}}}));
                }
            };
            peers[p].onaddstream = event => {
                node = createVideoNode(p);
                node.src = window.URL.createObjectURL(event.stream);
            };
            peers[p].createAnswer().then(answer => {
                peers[p].setLocalDescription(answer);
                ws.send(JSON.stringify({signal:{peer:p,signal:{answer:answer}}}));
            });
            peers[p].oniceconnectionstatechange = event => {
                if (peers[p].iceConnectionState === 'failed' || peers[p].iceConnectionState === 'disconnected') {
                    let node = document.getElementById('vid_remote_' + p);
                    if (node !== undefined) {
                        node.parentElement.removeChild(node);
                    }
                    peers[p] = undefined;
                }
            };
        }
        if (s.answer !== undefined) {
            peers[p].setRemoteDescription(s.answer);
        }
    }

    function createVideoNode(p) {
        let node = document.createElement('video');
        node.width = 600;
        node.height = 400;
        node.id = 'vid_remote_' + p;
        node.autoplay = 'true';
        document.getElementById('vid_remote').appendChild(node);

        let vids = document.querySelectorAll('#vid_remote video');
        let vidArray = Array.prototype.slice.call(vids, 0);
        vidArray.sort(function(a,b) {
            if (a.id < b.id) return -1;
            if (a.id > b.id) return 1;
            return 0;
        });
        let container = document.getElementById('vid_remote');
        container.parentElement.removeChild(container);
        while(container.firstChild) container.removeChild(container.firstChild);
        for (let i = 0; i < vidArray.length; i++)
            container.append(vidArray[i]);
        document.body.append(container);
        document.querySelectorAll('#vid_remote video').forEach(node => {
            try {
                node.play();
            }
            catch (err) {}
        });

        return document.getElementById('vid_remote_' + p);
    }

</script>
</body>
</html>